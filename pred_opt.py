"""Coupon assignment optimization approach with the use of the built predictive model

This script uses product purchase probabilities predicted by the built model
to estimate store revenues given specific coupon offering to the shoppers

To follow the objective of finding the coupon assignment that results
in the highest revenue uplift two approaches are used:
random search and the search with Optuna algorithm

Script must be run after data.py and model_training.py
"""

import lightgbm
import pandas as pd
import joblib
import final_project.data as lib
import pickle
import numpy as np
import random
import optuna
import os

if __name__ == "__main__":

    # read config
    config = lib.read_yaml("config.yaml")
    path_data = config["path"]
    path_results = f"{path_data}/results"
    os.makedirs(path_results, exist_ok=True)

    # load processed data, fully trained models list with cross-category relation maps
    prediction_set_cat = pd.read_parquet(f"{path_data}/processed/prediction_set_cat.pt")
    prediction_set_prod = pd.read_parquet(f"{path_data}/processed/prediction_set_prod.pt")

    prediction_set_cat = prediction_set_cat.reset_index(drop=True)
    prediction_set_prod = prediction_set_prod.reset_index(drop=True)

    lightgbm_classifier_cat = joblib.load(f"{path_data}/models/lightgbm_cat_level_model.pkl")
    lightgbm_classifier_prod = joblib.load(f"{path_data}/models/lightgbm_prod_level_model.pkl")

    with open(f"{path_data}/processed/cat_subst.txt", 'rb') as fp:
        cat_subst = pickle.load(fp)

    with open(f"{path_data}/processed/cat_compl.txt", 'rb') as fp:
        cat_compl = pickle.load(fp)


    def create_discount_feature_pred(dataset, subst_list=cat_subst, compl_list=cat_compl):
        """Simplified version of the function create_discount_features()

        Constructs discount-based features for one basket (shopper-week)
        """

        dataset['disc_subst'] = 0
        dataset['disc_compl'] = 0
        dataset['disc_self_cat'] = 0

        for i in range(max(dataset['category']) + 1):
            dataset.loc[dataset.category == i, 'disc_subst'] = sum(
                dataset[dataset.category.isin(subst_list[i])]['discount'])
            dataset.loc[dataset.category == i, 'disc_compl'] = sum(
                dataset[dataset.category.isin(compl_list[i])]['discount'])
            dataset.loc[dataset.category == i, 'disc_self_cat'] = sum(dataset[dataset.category == i]['discount'])
            dataset['disc_other_in_cat'] = dataset['disc_self_cat'] - dataset['discount']

        return dataset


    def revenue_per_shopper_pred(coupons, pred_set_cat, pred_set_prod):
        """Uses the built two-level model and two prediction datasets

        to estimate the weekly revenue generated by one shopper
        """

        pred_set_prod_b = pred_set_prod.copy()
        pred_set_prod_b = pred_set_prod_b.reset_index(drop=True)
        coupons = coupons.reset_index(drop=True)
        pred_set_prod_b = pd.concat([pred_set_prod_b, coupons], axis=1)
        pred_set_prod_b = create_discount_feature_pred(pred_set_prod_b)
        pred_set_cat_b = pred_set_cat.copy()
        pred_set_cat_b = pred_set_cat_b.merge(pred_set_prod_b[['category', 'disc_subst',
                                                               'disc_compl', 'disc_self_cat']],
                                              how='left', on='category')
        pred_set_cat_b = pred_set_cat_b.drop_duplicates()
        X_pred_cat = pred_set_cat_b[order_features_cat]
        pred_set_cat_b['y_category'] = lightgbm_classifier_cat.predict(X_pred_cat)
        pred_set_prod_b = pred_set_prod_b.merge(pred_set_cat_b[['category', 'y_category']], how='left', on='category')
        X_pred_prod = pred_set_prod_b[order_features_prod]
        pred_set_prod_b['purch_prob'] = lightgbm_classifier_prod.predict_proba(X_pred_prod)[:, 1]
        revenue = sum(pred_set_prod_b['max_price'] * (1 - pred_set_prod_b['discount']) * pred_set_prod_b['purch_prob'])

        return revenue


    def objective(trial):
        """Function that is optimized by Optuna algorithm

        to choose a better coupon assignment presented
        as hyperparameter configuration
        """

        # 15 hyperparameters: category, product (within category) and discount for each of 5 coupons
        c_1 = trial.suggest_int('category_1', 0, 24)
        pr_1 = trial.suggest_int('product_1', 0, 9)
        coup_1 = trial.suggest_categorical('discount_1', [0, 0.15, 0.2, 0.25, 0.3])
        c_2 = trial.suggest_int('category_2', 0, 24)
        pr_2 = trial.suggest_int('product_2', 0, 9)
        coup_2 = trial.suggest_categorical('discount_2', [0, 0.15, 0.2, 0.25, 0.3])
        c_3 = trial.suggest_int('category_3', 0, 24)
        pr_3 = trial.suggest_int('product_3', 0, 9)
        coup_3 = trial.suggest_categorical('discount_3', [0, 0.15, 0.2, 0.25, 0.3])
        c_4 = trial.suggest_int('category_4', 0, 24)
        pr_4 = trial.suggest_int('product_4', 0, 9)
        coup_4 = trial.suggest_categorical('discount_4', [0, 0.15, 0.2, 0.25, 0.3])
        c_5 = trial.suggest_int('category_5', 0, 24)
        pr_5 = trial.suggest_int('product_5', 0, 9)
        coup_5 = trial.suggest_categorical('discount_5', [0, 0.15, 0.2, 0.25, 0.3])

        pred_index.loc[pred_index['product'] == c_1 * 10 + pr_1, 'discount'] = coup_1
        pred_index.loc[pred_index['product'] == c_2 * 10 + pr_2, 'discount'] = coup_2
        pred_index.loc[pred_index['product'] == c_3 * 10 + pr_3, 'discount'] = coup_3
        pred_index.loc[pred_index['product'] == c_4 * 10 + pr_4, 'discount'] = coup_4
        pred_index.loc[pred_index['product'] == c_5 * 10 + pr_5, 'discount'] = coup_5

        revenue = revenue_per_shopper_pred(coupons=pred_index['discount'],
                                           pred_set_cat=pred_set_cat,
                                           pred_set_prod=pred_set_prod)
        # revenue uplift is the value that Optuna tries to maximize
        uplift = (revenue - base_revenue) / base_revenue
        pred_index.loc[:, 'discount'] = 0

        return uplift


    prediction_set_index = prediction_set_prod[['week', 'shopper', 'product', 'category']]
    prediction_set_index = prediction_set_index.reset_index(drop=True)
    prediction_set_index['discount'] = 0

    order_features_cat = ['avg_cat_price', 'disc_self_cat', 'disc_subst', 'disc_compl',
                          'time_since_last_purchase_of_category',
                          'avg_purch_freq_shift', 'redemption_rate_shift']
    order_features_prod = ['max_price', 'discount', 'disc_other_in_cat',
                           'time_since_last_purchase_of_product', 'avg_purch_freq_shift', 'redemption_rate_shift',
                           'y_category']

    # some valuable parameters
    n_prod = max(prediction_set_prod['product']) + 1
    n_cat = max(prediction_set_prod['category']) + 1
    n_shoppers = max(prediction_set_prod['shopper']) + 1

    # number of iterations algorithms perform per shopper
    n_iter = config['optimizer']['n_iter']

    pos_discounts = [0.15, 0.2, 0.25, 0.3]

    try:
        with open(f"{path_data}/processed/base_revenue_per_shopper.txt", 'rb') as fp:
            base_revenue_per_shopper = pickle.load(fp)
    except FileNotFoundError:
        base_revenue_per_shopper = []

    # base revenue (revenue given no coupon offerings) for each shopper is estimated
    for i in range(n_shoppers):
        base_revenue_per_shopper.append(
            revenue_per_shopper_pred(coupons=prediction_set_index[prediction_set_index.shopper == i]['discount'],
                                     pred_set_cat=prediction_set_cat[prediction_set_cat.shopper == i],
                                     pred_set_prod=prediction_set_prod[prediction_set_prod.shopper == i]))

    with open(f"{path_data}/processed/base_revenue_per_shopper.txt", 'wb') as fp:
        pickle.dump(base_revenue_per_shopper, fp)

    try:
        with open(f"{path_results}/coupon_assignments_random.txt", 'rb') as fp:
            coupons_per_shopper_randomsearch = pickle.load(fp)
    except FileNotFoundError:
        coupons_per_shopper_randomsearch = []

    # for-loop below performs random search of a better coupon assignment
    # per each shopper subsequently - takes a really long time to finish!

    for i in range(len(coupons_per_shopper_randomsearch), n_shoppers):
        shoppers = []
        predictions_per_shopper = prediction_set_index[prediction_set_index.shopper == i].copy()
        best_uplift = 0
        best_assignment = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]
        for j in range(n_iter):
            print(f"Iteration {j} is in the process")
            coup_disc = []
            cat_list = random.sample(range(n_cat), 5)
            for k in cat_list:
                spec_list = []
                pr = random.choice(list(predictions_per_shopper[predictions_per_shopper.category == k]['product']))
                dsc = random.choice([0, 0.15, 0.2, 0.25, 0.3])
                spec_list.append(pr)
                spec_list.append(dsc)
                predictions_per_shopper.loc[predictions_per_shopper['product'] == pr, 'discount'] = dsc
                coup_disc.append(spec_list)

            revenue = revenue_per_shopper_pred(coupons=predictions_per_shopper['discount'],
                                               pred_set_cat=prediction_set_cat[prediction_set_cat.shopper == i].copy(),
                                               pred_set_prod=prediction_set_prod[
                                                   prediction_set_prod.shopper == i].copy())

            if revenue - base_revenue_per_shopper[i] > best_uplift:
                best_uplift = revenue - base_revenue_per_shopper[i]
                best_assignment = coup_disc
                best_assignment.append(best_uplift / base_revenue_per_shopper[i])
            print(
                f"The best coupon assignment for shopper {i} after {j + 1} iterations is {best_assignment}. "
                f"The revenue uplift is {best_uplift / base_revenue_per_shopper[i]}")
            predictions_per_shopper.loc[:, 'discount'] = 0
        coupons_per_shopper_randomsearch.append(best_assignment)
        # to secure the training process the list of found coupon assignments
        # is saved each 50 shoppers
        if i % 50 == 0:
            with open(f"{path_results}/coupon_assignments_random.txt", 'wb') as fp:
                pickle.dump(coupons_per_shopper_randomsearch, fp)

    with open(f"{path_results}/coupon_assignments_random.txt", 'wb') as fp:
        pickle.dump(coupons_per_shopper_randomsearch, fp)

    try:
        with open(f"{path_results}/coupon_assignments_optuna.txt", 'rb') as fp:
            coupons_per_shopper_optuna = pickle.load(fp)
    except FileNotFoundError:
        coupons_per_shopper_optuna = []

    # for-loop below performs search by Optuna algorithm of a better coupon assignment
    # per each shopper subsequently - takes a really long time to finish!

    for i in range(len(coupons_per_shopper_optuna), n_shoppers):
        pred_set_cat = prediction_set_cat[prediction_set_cat.shopper == i].copy()
        pred_index = prediction_set_index[prediction_set_index.shopper == i].copy()
        pred_set_prod = prediction_set_prod[prediction_set_prod.shopper == i].copy()
        base_revenue = base_revenue_per_shopper[i]

        study = optuna.create_study(direction="maximize")
        study.optimize(objective, n_trials=100)

        print("Number of finished trials: {}".format(len(study.trials)))

        print("Best trial:")
        trial = study.best_trial

        print("  The value of uplift for shopper {}: {}".format(i, trial.value))

        print("  Params for shopper {}: ".format(i))
        for key, value in trial.params.items():
            print("    {}: {}".format(key, value))
        assingment_shopper = [study.best_params, study.best_value]

        coupons_per_shopper_optuna.append(assingment_shopper)
        if i % 50 == 0:
            with open(f"{path_results}/coupon_assignments_optuna.txt", 'wb') as fp:
                pickle.dump(coupons_per_shopper_optuna, fp)

    with open(f"{path_results}/coupon_assignments_optuna.txt", 'wb') as fp:
        pickle.dump(coupons_per_shopper_optuna, fp)

    revenue_estimates = pd.DataFrame(base_revenue_per_shopper)
    revenue_estimates = revenue_estimates.rename(columns={0: "base_revenue"})

    uplift_random_search = []
    uplift_optuna = []
    for i in range(n_shoppers):
        uplift_random_search.append(coupons_per_shopper_randomsearch[i][-1])
        uplift_optuna.append(coupons_per_shopper_optuna[i][-1])

    revenue_estimates['uplift_random_search'] = np.array(uplift_random_search)
    revenue_estimates['uplift_optuna'] = np.array(uplift_optuna)

    type_list = []
    for i in range(n_shoppers):
        type_list.append(type(uplift_random_search[i]))

    df_spec = pd.DataFrame(type_list)
    problems = list(df_spec[df_spec[0] != float].index)

    revenue_estimates.iloc[problems, revenue_estimates.columns.get_loc('uplift_random_search')] = 0

    # for each of the two shoppers it is determined which of the approaches performed better
    # (higher revenue uplift is predicted)
    revenue_estimates['optuna_is_better'] = revenue_estimates['uplift_optuna'] > revenue_estimates[
        'uplift_random_search']

    coupon_index = pd.read_parquet(f"{path_data}/coupon_index.parquet")
    coupon_index['product'] = 0
    coupon_index['discount'] = 0
    coupon_index = coupon_index.reset_index(drop=True)

    # best found coupon arrangements are put into the solution dataset
    for i in range(n_shoppers):
        if revenue_estimates.iloc[i, revenue_estimates.columns.get_loc('optuna_is_better')]:
            coupon_index.loc[(coupon_index['shopper'] == i) &
                             (coupon_index['coupon'] == 0), 'product'] = 10 * coupons_per_shopper_optuna[i][0][
                'category_1'] + coupons_per_shopper_optuna[i][0]['product_1']
            coupon_index.loc[(coupon_index['shopper'] == i) & (coupon_index['coupon'] == 0),
                             'discount'] = coupons_per_shopper_optuna[i][0]['discount_1']

            coupon_index.loc[(coupon_index['shopper'] == i) &
                             (coupon_index['coupon'] == 1), 'product'] = 10 * coupons_per_shopper_optuna[i][0][
                'category_1'] + coupons_per_shopper_optuna[i][0]['product_2']
            coupon_index.loc[(coupon_index['shopper'] == i) & (coupon_index['coupon'] == 1),
                             'discount'] = coupons_per_shopper_optuna[i][0]['discount_1']

            coupon_index.loc[(coupon_index['shopper'] == i) &
                             (coupon_index['coupon'] == 2), 'product'] = 10 * coupons_per_shopper_optuna[i][0][
                'category_1'] + coupons_per_shopper_optuna[i][0]['product_3']
            coupon_index.loc[(coupon_index['shopper'] == i) & (coupon_index['coupon'] == 2),
                             'discount'] = coupons_per_shopper_optuna[i][0]['discount_1']

            coupon_index.loc[(coupon_index['shopper'] == i) &
                             (coupon_index['coupon'] == 3), 'product'] = 10 * coupons_per_shopper_optuna[i][0][
                'category_1'] + coupons_per_shopper_optuna[i][0]['product_4']
            coupon_index.loc[(coupon_index['shopper'] == i) & (coupon_index['coupon'] == 3),
                             'discount'] = coupons_per_shopper_optuna[i][0]['discount_1']

            coupon_index.loc[(coupon_index['shopper'] == i) &
                             (coupon_index['coupon'] == 4), 'product'] = 10 * coupons_per_shopper_optuna[i][0][
                'category_1'] + coupons_per_shopper_optuna[i][0]['product_5']
            coupon_index.loc[(coupon_index['shopper'] == i) & (coupon_index['coupon'] == 4),
                             'discount'] = coupons_per_shopper_optuna[i][0]['discount_1']
        else:
            for j in range(5):
                coupon_index.loc[(coupon_index['shopper'] == i) & (coupon_index['coupon'] == j),
                                 'product'] = coupons_per_shopper_randomsearch[i][j][0]
                coupon_index.loc[(coupon_index['shopper'] == i) & (coupon_index['coupon'] == j),
                                 'discount'] = coupons_per_shopper_randomsearch[i][j][1]

    coupon_index.to_parquet(f"{path_results}/coupon_solution.pt")
